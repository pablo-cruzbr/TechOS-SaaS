import React, { useState, useEffect, useRef, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Dimensions,
  ScrollView,
  Linking,
  Image,
  Alert,
} from "react-native";
import { OrdensDeServico } from "../../pages/Dashboard";
import { MaterialIcons } from "@expo/vector-icons";
import { ModalDetailOrderFormTecnico } from "../modalDetailOrderFormTecnico";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { api } from "../../services/api";
import * as ImagePicker from "expo-image-picker";

interface ModalDetailOsProps {
  ordem: OrdensDeServico | null;
  handleCloseModal: () => void;
}

const { width: WIDTH, height: HEIGHT } = Dimensions.get("window");
const IMAGE_SIZE = (WIDTH - 90) / 3;

/**
 * ModalDetailOrder (refatorado)
 *
 * Mudanças principais:
 * - Consolidei as requisições iniciais em um único useEffect (quando `ordem` muda).
 * - Controle de loading global (`isLoading`) para evitar chamadas paralelas redundantes.
 * - Timer separado: um useEffect leve que escuta `isRunning` e atualiza `time` com um único interval guardado em ref.
 * - Funções de API com token reutilizável (obtido uma vez) e tratativas de erro.
 * - Uso de useRef para evitar intervals duplicados e para checar se o componente continua montado.
 *
 * Objetivo: reduzir re-renders e evitar loops que causam crash.
 */

export function ModalDetailOrder({ ordem, handleCloseModal }: ModalDetailOsProps) {
  const [modalTecnicoOpen, setModalTecnicoOpen] = useState(false);
  const [ordemAtual, setOrdemAtual] = useState<OrdensDeServico | null>(ordem);
  const [selectedImages, setSelectedImages] = useState<{ uri: string; base64: string }[]>([]);
  const [isRunning, setIsRunning] = useState(false);
  const [time, setTime] = useState(0);
  const [assinatura, setAssinatura] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // ref para armazenar o id do intervalo do timer e evitar múltiplos intervals
  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  // ref para checar se o componente está montado (evitar setState após unmount)
  const isMountedRef = useRef(true);

  useEffect(() => {
    console.log(">>> Carregando OS inicial - ordem prop:", ordem);
console.log(">>> api baseURL:", (api as any).defaults?.baseURL);

    // marca como montado quando montado; limpa no unmount
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, []);

  const formatTime = (seconds: number) => {
    const h = Math.floor(seconds / 3600).toString().padStart(2, "0");
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, "0");
    const s = (seconds % 60).toString().padStart(2, "0");
    return `${h}:${m}:${s}`;
  };

  const abrirWaze = (endereco: string) => {
    const url = `https://waze.com/ul?q=${encodeURIComponent(endereco)}`;
    Linking.canOpenURL(url).then((supported) =>
      supported ? Linking.openURL(url) : Alert.alert("Erro", "Não foi possível abrir o Waze.")
    );
  };

  const abrirGoogleMaps = (endereco: string) => {
    const url = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(endereco)}`;
    Linking.openURL(url);
  };

  const atualizarOrdem = () => setOrdemAtual((prev) => (prev ? { ...prev } : prev));

  // ----- Função utilitária para obter token (reutilizada) -----
  const getToken = useCallback(async (): Promise<string | null> => {
    try {
      const storageToken = await AsyncStorage.getItem("@AlltiService");
      if (!storageToken) return null;
      const { token } = JSON.parse(storageToken);
      return token ?? null;
    } catch (err) {
      console.error("Erro ao ler token do AsyncStorage", err);
      return null;
    }
  }, []);

  // ----- Função que atualiza os campos de tempo e o estado do timer baseado na resposta -----
  const applyTempoData = useCallback(
    (data: any) => {
      if (!isMountedRef.current) return;
      const { duracao, startedAt, endedAt } = data ?? {};
      if (duracao) {
        setTime(duracao);
        setIsRunning(!endedAt); // se terminou, isRunning false
      } else if (startedAt && !endedAt) {
        const diff = Math.floor((new Date().getTime() - new Date(startedAt).getTime()) / 1000);
        setTime(diff);
        setIsRunning(true);
      } else {
        setTime(0);
        setIsRunning(false);
      }

      // Atualiza somente os campos relacionados ao tempo na ordem atual
      setOrdemAtual((prev) => {
        if (!prev) return prev;
        return { ...prev, startedAt, endedAt, duracao };
      });
    },
    []
  );

  // ----- Função que refresh da OS (usada após patches) -----
  const refreshOrdemAtual = useCallback(
    async (ordemId?: string) => {
      if (!ordemId && !ordemAtual?.id) return;
      const id = ordemId ?? ordemAtual!.id;
      try {
        const token = await getToken();
        if (!token) return;
        const { data } = await api.get(`/ordemdeservico/tempo/${id}`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!isMountedRef.current) return;
        // aplica os dados de tempo recebidos
        applyTempoData(data);
      } catch (error) {
        console.error("Erro ao refreshOrdemAtual:", error);
      }
    },
    [ordenAtualPlaceholder()],
  );

  // note: workaround to satisfy linter about ordemAtual dependency - we'll implement a no-op function
  function ordenAtualPlaceholder() {
    // função vazia apenas para manter dependências claras.
    return null;
  }

  // ----- Função para buscar assinatura (se existir) -----
  const fetchAssinatura = useCallback(
    async (ordemId: string) => {
      try {
        const token = await getToken();
        if (!token) return;
        const response = await api.get(`/assinatura/${ordemId}`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!isMountedRef.current) return;
        setAssinatura(response.data?.assinatura ?? null);
      } catch (err) {
        console.error("Erro ao buscar assinatura:", err);
      }
    },
    [getToken]
  );

  // ----- useEffect de inicialização: quando "ordem" (prop) muda, traz dados necessários em 1 bloco -----
  useEffect(() => {
    if (!ordem) {
      // se não recebeu ordem, limpa estados relevantes
      setOrdemAtual(null);
      setAssinatura(null);
      setTime(0);
      setIsRunning(false);
      return;
    }

    let cancelled = false;
    const loadAll = async () => {
      setIsLoading(true);
      try {
        const token = await getToken();
        if (!token) {
          console.warn("Token ausente ao carregar ordem");
          setIsLoading(false);
          return;
        }

        // Dispara as requisições principais em paralelo (ordem geral, assinatura e tempo)
        // Mantemos as rotas que você usava: /ordemdeservico/:id, /assinatura/:id, /ordemdeservico/tempo/:id
            console.log(">>> endpoint tentativa:", `/ordemdeservico/${ordem.id}`);
        const [ordemResp, assinaturaResp, tempoResp] = await Promise.all([
      
          api.get(`/ordemdeservico/${ordem.id}`, { headers: { Authorization: `Bearer ${token}` } }),
          api.get(`/assinatura/${ordem.id}`, { headers: { Authorization: `Bearer ${token}` } }).catch(() => ({ data: null })), // aceita falha sem quebrar tudo
          api.get(`/ordemdeservico/tempo/${ordem.id}`, { headers: { Authorization: `Bearer ${token}` } }).catch(() => ({ data: null })),
          
        ]);

        if (cancelled || !isMountedRef.current) return;

        // atualiza ordem completa
        const ordemData = ordemResp.data;
        setOrdemAtual(ordemData);

        // assinatura (se houver)
        setAssinatura(assinaturaResp?.data?.assinatura ?? null);

        // aplica lógica de tempo via helper (centraliza comportamento)
        applyTempoData(tempoResp?.data ?? null);
      } catch (err) {
        console.error("Erro ao carregar dados iniciais da OS:", err);
        Alert.alert("Erro", "Falha ao carregar informações da ordem. Tente novamente.");
      } finally {
        if (!cancelled && isMountedRef.current) setIsLoading(false);
      }
    };

    loadAll();

    return () => {
      cancelled = true; // cancela caso o efeito seja desmontado/atualizado
    };
    // Disparar quando a prop 'ordem' muda.
  }, [ordem, getToken, applyTempoData]);

  // ----- Timer: singelo useEffect que controla o interval com base em isRunning -----
  useEffect(() => {
    // se já existe interval, limpa antes de criar outro
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }

    if (isRunning) {
      intervalRef.current = setInterval(() => {
        // atualiza o tempo cada 1s
        setTime((prev) => prev + 1);
      }, 1000);
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [isRunning]);

  // ----- enviarAssinatura (patch) -----
  const enviarAssinatura = useCallback(
    async (base64: string) => {
      if (!ordemAtual?.id) return;
      try {
        const token = await getToken();
        if (!token) return;
        await api.patch(
          `/assinatura/${ordemAtual.id}`,
          { assinatura: base64 },
          { headers: { Authorization: `Bearer ${token}` } }
        );
        if (!isMountedRef.current) return;
        setAssinatura(base64);
        Alert.alert("Sucesso", "Assinatura salva!");
      } catch (err) {
        console.error("Erro ao salvar assinatura:", err);
        Alert.alert("Erro", "Não foi possível salvar a assinatura.");
      }
    },
    [ordemAtual?.id, getToken]
  );

  // ----- Upload de imagens (POST) -----
  const uploadImages = useCallback(
    async () => {
      if (selectedImages.length === 0) return Alert.alert("Atenção", "Selecione pelo menos uma imagem.");
      if (!ordemAtual?.id) return Alert.alert("Erro", "Ordem inválida.");

      const formData = new FormData();
      formData.append("ordemdeServico_id", ordemAtual.id);

      selectedImages.forEach((img, index) => {
        formData.append("file", {
          uri: img.uri,
          name: `ordem_${ordemAtual.id}_${index}.jpg`,
          type: "image/jpeg",
        } as any);
      });

      try {
        const token = await getToken();
        if (!token) return;
        await api.post(`/foto`, formData, {
          headers: { "Content-Type": "multipart/form-data", Authorization: `Bearer ${token}` },
          timeout: 30000,
        });
        if (!isMountedRef.current) return;
        Alert.alert("Sucesso", "Imagens enviadas com sucesso!");
        setSelectedImages([]);
        // atualiza a ordem após upload (caso o backend adicione URLs)
        await refreshOrdemAtual(ordemAtual.id);
      } catch (err: unknown) {
        const error = err as any;
        console.error("Erro no upload de imagens:", error.response?.data || error.message);
        Alert.alert("Erro", "Falha ao enviar imagens.");
      }
    },
    [selectedImages, ordemAtual?.id, getToken, refreshOrdemAtual]
  );

  // ----- pickImages / openCamera (mantidos, mas seguros) -----
  const pickImages = useCallback(async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== "granted") return Alert.alert("Permissão negada", "Habilite o acesso às fotos.");

    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsMultipleSelection: true,
      quality: 1,
      base64: true,
    });

    if (!result.canceled) {
      const imagesWithBase64 = result.assets.map((asset) => ({
        uri: asset.uri,
        base64: `data:${asset.type};base64,${asset.base64}`,
      }));
      setSelectedImages((prev) => [...prev, ...imagesWithBase64]);
    }
  }, []);

  const openCamera = useCallback(async () => {
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    if (status !== "granted") return Alert.alert("Permissão negada", "Habilite o acesso à câmera.");

    const result = await ImagePicker.launchCameraAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      quality: 1,
      base64: true,
    });

    if (!result.canceled) {
      const imagesWithBase64 = result.assets.map((asset) => ({
        uri: asset.uri,
        base64: `data:${asset.type};base64,${asset.base64}`,
      }));
      setSelectedImages((prev) => [...prev, ...imagesWithBase64]);
    }
  }, []);

  const removeImage = useCallback((index: number) => {
    setSelectedImages((prev) => prev.filter((_, i) => i !== index));
  }, []);

  // ----- Iniciar OS (patch) -----
  const handleStart = useCallback(async () => {
    if (!ordemAtual?.id) {
      console.error("Ordem inválida ao iniciar:", ordemAtual);
      return;
    }
    try {
      const token = await getToken();
      if (!token) {
        console.error("Token ausente ao iniciar OS");
        return;
      }
      await api.patch(`/ordemdeservico/iniciar/${ordemAtual.id}`, {}, {
        headers: { Authorization: `Bearer ${token}` },
      });
      // atualiza apenas os campos de tempo
      await refreshOrdemAtual(ordemAtual.id);
    } catch (error) {
      console.error("Erro ao iniciar OS:", error);
      Alert.alert("Erro", "Não foi possível iniciar a OS.");
    }
  }, [ordemAtual?.id, getToken, refreshOrdemAtual]);

  // ----- Pausar / concluir (patch) -----
  const handlePause = useCallback(async () => {
    if (!ordemAtual?.id) {
      console.error("Ordem inválida ao pausar:", ordemAtual);
      return;
    }
    try {
      const token = await getToken();
      if (!token) return;
      const payload = { endedAt: new Date().toISOString() };
      await api.patch(`/ordemdeservico/concluir/${ordemAtual.id}`, payload, {
        headers: { Authorization: `Bearer ${token}` },
      });
      await refreshOrdemAtual(ordemAtual.id);
    } catch (error) {
      console.error("Erro ao pausar OS:", error);
      Alert.alert("Erro", "Não foi possível pausar a OS.");
    }
  }, [ordemAtual?.id, getToken, refreshOrdemAtual]);

  // ----- Concluir e fechar (patch) -----
  const handleCloseAndComplete = useCallback(async () => {
    if (!ordemAtual?.id) {
      console.error("Ordem inválida ao concluir:", ordemAtual);
      return;
    }
    try {
      const token = await getToken();
      if (!token) return;
      await api.patch(`/ordemdeservico/concluir/${ordemAtual.id}`, {}, {
        headers: { Authorization: `Bearer ${token}` },
      });
      await refreshOrdemAtual(ordemAtual.id);
      handleCloseModal();
    } catch (error) {
      console.error("Erro ao concluir OS:", error);
      Alert.alert("Erro", "Não foi possível concluir a OS.");
    }
  }, [ordemAtual?.id, getToken, refreshOrdemAtual, handleCloseModal]);

  // Se ordemAtual ainda não foi carregada, evita crash (render null - mantém UX atual)
  if (!ordemAtual) return null;

  const endereco = ordemAtual.user?.cliente?.endereco ?? ordemAtual.instituicaoUnidade?.endereco ?? "";

  return (
    <>
      <TouchableOpacity activeOpacity={1} style={styles.overlay} onPress={handleCloseModal}>
        <TouchableOpacity activeOpacity={1} style={styles.modalContainer}>
          <ScrollView showsVerticalScrollIndicator>
            {/* === HEADER === */}
            <View style={styles.header}>
              <Text style={styles.title}>Detalhes da Ordem</Text>
              <TouchableOpacity onPress={atualizarOrdem} style={styles.refreshIcon}>
                <MaterialIcons name="refresh" size={24} color="#0F1431" />
              </TouchableOpacity>
              <TouchableOpacity onPress={handleCloseModal} style={styles.closeIcon}>
                <MaterialIcons name="close" size={24} color="#0F1431" />
              </TouchableOpacity>
            </View>

            {/* Informações adicionais do setor */}
            {ordemAtual.informacoesSetor && (
              <View style={{ marginTop: 20 }}>
                <Text style={styles.label}>Local do Chamado: </Text>

                {ordemAtual?.informacoesSetor?.instituicaoUnidade?.name ? (
                  <Text>{ordemAtual.informacoesSetor.instituicaoUnidade.name}</Text>
                ) : ordemAtual?.informacoesSetor?.cliente?.name ? (
                  <Text>{ordemAtual.informacoesSetor.cliente.name}</Text>
                ) : (
                  <Text>Não informado</Text>
                )}

                <Text style={styles.label}>Informações do usuário que solicitou o chamado</Text>

                <Text>Setor: {ordemAtual.informacoesSetor.setor.name}</Text>
                <Text>Usuário: {ordemAtual.informacoesSetor.usuario}</Text>
                <Text>Ramal: {ordemAtual.informacoesSetor.ramal}</Text>
                <Text>Andar: {ordemAtual.informacoesSetor.andar}</Text>
              </View>
            )}

            {/* === INFORMAÇÕES === */}
            <Text style={styles.label}>Número: {ordemAtual.numeroOS ?? "Não Disponível"}</Text>
            <Text style={styles.label}>Status:</Text>
            <Text>{ordemAtual.statusOrdemdeServico?.name ?? "-"}</Text>
            <Text style={styles.label}>Quem abriu a OS:</Text>
            <Text>{ordemAtual.name}</Text>

            {ordemAtual.user?.cliente ? (
              <>
                <Text style={styles.label}>Empresa:</Text>
                <Text>{ordemAtual.user.cliente.name}</Text>
                <Text style={styles.label}>Endereço:</Text>
                <Text>{ordemAtual.user.cliente.endereco}</Text>
              </>
            ) : ordemAtual.instituicaoUnidade ? (
              <>
                <Text style={styles.label}>Instituição:</Text>
                <Text>{ordemAtual.instituicaoUnidade.name}</Text>
                <Text style={styles.label}>Endereço:</Text>
                <Text>{ordemAtual.instituicaoUnidade.endereco}</Text>
              </>
            ) : (
              <>
                <Text style={styles.label}>Endereço:</Text>
                <Text>-</Text>
              </>
            )}

            {endereco && (
              <>
                <TouchableOpacity style={[styles.buttonClose, styles.buttonNavigation]} onPress={() => abrirWaze(endereco)}>
                  <View style={styles.buttonContent}>
                    <MaterialIcons name="navigation" size={20} color="#FFF" />
                    <Text style={styles.textButtonClose}>ABRIR NO WAZE</Text>
                  </View>
                </TouchableOpacity>
                <TouchableOpacity style={[styles.buttonClose, styles.buttonNavigation]} onPress={() => abrirGoogleMaps(endereco)}>
                  <View style={styles.buttonContent}>
                    <MaterialIcons name="map" size={20} color="#FFF" />
                    <Text style={styles.textButtonClose}>ABRIR NO GOOGLE MAPS</Text>
                  </View>
                </TouchableOpacity>
              </>
            )}

            <View style={styles.timerContainer}>
              <Text style={styles.timerText}>Tempo decorrido: {formatTime(time)}</Text>
              <View style={styles.timerButtons}>
                {!isRunning ? (
                  <TouchableOpacity style={[styles.buttonClose, styles.timerBtn]} onPress={handleStart}>
                    <Text style={styles.textButtonClose}>Iniciar</Text>
                  </TouchableOpacity>
                ) : (
                  <TouchableOpacity style={[styles.buttonClose, styles.timerBtnPause]} onPress={handlePause}>
                    <Text style={styles.textButtonClose}>Pausar</Text>
                  </TouchableOpacity>
                )}

                <TouchableOpacity style={[styles.buttonClose, styles.timerBtnReset]} onPress={() => { setIsRunning(false); setTime(0); }}>
                  <Text style={styles.textButtonClose}>Resetar</Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* === DETALHES === */}
            <Text style={styles.label}>Tipo de Chamado:</Text>
            <Text>{ordemAtual.tipodeChamado?.name ?? "-"}</Text>
            <Text style={styles.label}>Problema:</Text>
            <Text>{ordemAtual.descricaodoProblemaouSolicitacao}</Text>
            <Text style={styles.label}>Contato no Local:</Text>
            <Text>{ordemAtual.nomedoContatoaserProcuradonoLocal}</Text>
            <Text style={styles.label}>Técnico:</Text>
            <Text>{ordemAtual.nameTecnico ?? "-"}</Text>
            <Text style={styles.label}>Diagnóstico:</Text>
            <Text>{ordemAtual.diagnostico ?? "-"}</Text>
            <Text style={styles.label}>Solução:</Text>
            <Text>{ordemAtual.solucao ?? "-"}</Text>

            <Text style={styles.label}>Início da OS:</Text>
            <Text>
              {ordemAtual?.startedAt
                ? new Date(ordemAtual.startedAt).toLocaleTimeString("pt-BR", {
                    timeZone: "America/Sao_Paulo",
                    hour: "2-digit",
                    minute: "2-digit",
                  })
                : "-"}
            </Text>

            <Text style={styles.label}>Término da OS:</Text>
            <Text>
              {ordemAtual?.endedAt
                ? new Date(ordemAtual.endedAt).toLocaleTimeString("pt-BR", {
                    timeZone: "America/Sao_Paulo",
                    hour: "2-digit",
                    minute: "2-digit",
                  })
                : isRunning
                ? "Em andamento..."
                : "-"}
            </Text>

            <Text style={styles.label}>Duração:</Text>
            <Text>{formatTime(time)}</Text>

            <Text style={styles.label}>Assinatura:</Text>
            <Text>Pessoa que Assinou: {ordemAtual.assinante ?? "-"}</Text>

            {/* === ASSINATURA === */}
            {assinatura ? (
              <Image source={{ uri: assinatura }} style={{ width: 300, height: 230, marginTop: 5, borderWidth: 1, borderColor: "#000" }} />
            ) : (
              <TouchableOpacity style={styles.buttonClose} onPress={() => Alert.alert("Assinatura", "Implementar captura de assinatura aqui")}>
                <Text style={styles.textButtonClose}>ADICIONAR ASSINATURA</Text>
              </TouchableOpacity>
            )}

            {/* === IMAGENS === */}
            <TouchableOpacity style={styles.buttonClose} onPress={pickImages}>
              <View style={styles.buttonContent}>
                <MaterialIcons name="photo-library" size={20} color="#FFF" />
                <Text style={styles.textButtonClose}>SELECIONAR IMAGENS</Text>
              </View>
            </TouchableOpacity>

            <TouchableOpacity style={styles.buttonClose} onPress={openCamera}>
              <View style={styles.buttonContent}>
                <MaterialIcons name="photo-camera" size={20} color="#FFF" />
                <Text style={styles.textButtonClose}>TIRAR FOTO</Text>
              </View>
            </TouchableOpacity>

            {selectedImages.length > 0 && (
              <>
                <View style={styles.gridImages}>
                  {selectedImages.map((img, index) => (
                    <View key={index} style={styles.imageWrapper}>
                      <Image source={{ uri: img.uri }} style={styles.imageItem} />
                      <TouchableOpacity style={styles.removeButton} onPress={() => removeImage(index)}>
                        <MaterialIcons name="close" size={16} color="#FFF" />
                      </TouchableOpacity>
                    </View>
                  ))}
                </View>
                <TouchableOpacity style={styles.buttonClose} onPress={uploadImages}>
                  <View style={styles.buttonContent}>
                    <MaterialIcons name="cloud-upload" size={20} color="#FFF" />
                    <Text style={styles.textButtonClose}>ENVIAR TODAS</Text>
                  </View>
                </TouchableOpacity>
              </>
            )}

            <TouchableOpacity style={styles.buttonClose} onPress={() => setModalTecnicoOpen(true)}>
              <View style={styles.buttonContent}>
                <MaterialIcons name="description" size={20} color="#FFF" />
                <Text style={styles.textButtonClose}>ADICIONAR DESCRIÇÃO TÉCNICA</Text>
              </View>
            </TouchableOpacity>

            <TouchableOpacity style={[styles.buttonClose, styles.buttonComplete]} onPress={handleCloseAndComplete}>
              <View style={styles.buttonContent}>
                <MaterialIcons name="check-circle" size={20} color="#FFF" />
                <Text style={styles.textButtonClose}>CONCLUIR E FECHAR</Text>
              </View>
            </TouchableOpacity>

            {/* indica loading básico (opcional) */}
            {isLoading && <Text style={{ marginTop: 10 }}>Carregando informações...</Text>}
          </ScrollView>
        </TouchableOpacity>
      </TouchableOpacity>

      {modalTecnicoOpen && (
        <ModalDetailOrderFormTecnico ordemId={ordemAtual.id} handleCloseModal={() => setModalTecnicoOpen(false)} />
      )}
    </>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
  },

  modalContainer: {
    width: WIDTH - 15,
    maxHeight: HEIGHT - 100,
    backgroundColor: "#FFF",
    borderRadius: 8,
    padding: 20,
  },

  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 10,
  },

  title: {
    fontSize: 20,
    fontWeight: "bold",
  },

  refreshIcon: {
    left: 40,
  },

  closeIcon: {
    right: 4,
  },

  label: {
    marginTop: 10,
    fontWeight: "bold",
  },

  buttonClose: {
    marginTop: 20,
    backgroundColor: "#3859F3",
    padding: 12,
    borderRadius: 8,
    alignItems: "center",
  },

  buttonContent: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
  },

  textButtonClose: {
    color: "#FFF",
    fontWeight: "bold",
    marginLeft: 8,
  },

  buttonNavigation: {
    backgroundColor: "#3859F3",
  },

  timerContainer: {
    marginVertical: 15,
    alignItems: "center",
  },

  timerText: {
    fontSize: 16,
    fontWeight: "bold",
  },

  timerButtons: {
    flexDirection: "row",
    marginTop: 10,
  },

  timerBtn: {
    marginRight: 10,
    backgroundColor: "#3859F3",
  },

  timerBtnPause: {
    marginRight: 10,
    backgroundColor: "#888",
  },

  timerBtnReset: {
    backgroundColor: "#555",
  },

  gridImages: {
    flexDirection: "row",
    flexWrap: "wrap",
    marginTop: 10,
  },

  imageWrapper: {
    width: IMAGE_SIZE,
    height: IMAGE_SIZE,
    marginRight: 10,
    marginBottom: 10,
    position: "relative",
  },

  imageItem: {
    width: "100%",
    height: "100%",
    borderRadius: 8,
  },

  removeButton: {
    position: "absolute",
    top: 5,
    right: 5,
    backgroundColor: "rgba(0,0,0,0.6)",
    borderRadius: 12,
    padding: 2,
    zIndex: 10,
  },

  buttonComplete: {
    backgroundColor: "green",
  },
});
